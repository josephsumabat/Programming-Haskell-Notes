\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\usepackage{hyperref}
\usepackage{fancyvrb}
\usepackage{graphicx}
\usepackage[section]{placeins}
\title{Haskell Learning}
\author{Joseph Sumabat}
\date{}

\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Introduction}
  This document is for me to document my learning particularly with respect to Haskell.
  \subsection{Resources}
  Listed here are any resources I used or have found useful in my learning process
  \begin{itemize}
    \item
      \href
      {https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/}
      {Category theory for programmers} by Bartosz Milewski
    \item
      \href
      {http://math.andrej.com/2016/08/06/hask-is-not-a-category/}
      {Hask is not a category} by Andrej Bauer
    \item
      \href
      {https://wiki.haskell.org/Haskell}
      {Haskell Wiki}
      \begin{itemize}
        \item
          \href
          {https://wiki.haskell.org/Hask}
          {The category Hask}
      \end{itemize}
    \item
      \href
      {https://www.cs.ox.ac.uk/jeremy.gibbons/publications/fast+loose.pdf}
      {Fast and loose reasoning is morally correct} by Jeremy Gibbons
    \item
      \href
      {https://codewords.recurse.com/issues/three/algebra-and-calculus-of-algebraic-data-types}
      {The Algebra (and calculus!) of Algebraic Data types} by John Burget
    \item
      \href
      {https://www.cs.kent.ac.uk/people/staff/sjt/TTFP/}
      {Type Theory and Functional Programming} by Simon Thompson
  \end{itemize}

\section{Types}

\subsection{Hask}
  "Objects of Hask are Haskell Types".
  \bigskip

  Haskell types can be \textbf{thought of} like sets \footnote{There is a distinction between
  set and object of category hask (or set) }. e.g. \verb Int  could be thought
  of as the set of values from $\{-2^{29},..,2^{29} - 1\}$ and \verb|Boolean| as
  the set containing two elements $\{True, False\}$
  \bigskip

  \subsubsection{Bottom Type}
  These types actually contain an additional value of $\bot$ which is a value
  \textbf{included in every type} allowing for computations which don't
  terminate.  
  \bigskip

  $\bot$ is necessary because of the existance of general recursion and is
  witnessed by the equation $x = x$.

  \subsubsection{Hask is not a category}
  Because of the existance of both $\bot$ and the fact that Haskell is a
  non-strict language with the function \verb|seq| defined, Hask actually
  violates the category laws of category theory.
  \bigskip

  We usually think of working within a limited subset without either bottom
  values or \verb|seq| so that we can apply category theorestic principles.

\subsection{Constructive vs Classical logic}
  Philosophically the difference is in having to prove things via a construction
  \bigskip
  
  In classical  logic every proposition is assigned a value $T$ or $F$ by law
  of excluded middle (think truth tables). \textbf{this is not the case for constructive logic}
  In constructive logic we lose out on law of excluded middle and by extension
  proofs by contradiction. Instead in order to prove things we must show that a proposition is
  \textit{witnessed} (in this context inhabited).

\begin{itemize}
  \item
\end{itemize}
\subsection{Curry Howard Isomorphism}

Isomorphism between types and Proofs. Haskell types have a mapping to \textbf{Propositional} Logic
Note that more powerful type systems can map to more powerful systems of logic (Dependent types can
correspond to predicate logic for example)
\begin{itemize}
  \item Think of a Haskell type as a set and a program as a proof that such a set is inhabited
  \item From my understanding: Your compiler also functions as a proof checker
  \item From a practical standpoint this means that 
  \item Note: Haskell
\end{itemize}
     Note that the propositional logic system that Haskell types map to is \textbf{unsound}
     due to the bottom type ($\bot$) which inhabits every type including void. Consider the
     following example:
    \begin{verbatim}
      absurd::() -> Void
      absurd a = undefined
    \end{verbatim}
      Because the void type corresponds to $False$ and the unit type to $True$
      we have $True \rightarrow False$ which is clearly unsound. However we note
      that the bottom type terminates the program so I'm not entirely sure whether
      you can consider it a value.

\subsection{More powerful type systems (dependent types)}

\section{Language and Examples}

\subsection{Making types}
\begin{itemize}
  \item  Haskell has generalized algebraic datatypes (GADTs)
    \begin{itemize}
      \item sum type using \verb.|. and product type as multiple parameters
            to a type constructor
   \end{itemize}
 \item Types can be recursively defined as below:
\end{itemize}
Sum type example:
    \begin{verbatim}
      data Boolean = True | False
    \end{verbatim}
Product Type example:
    \begin{verbatim}
      data Pair a = Pair a a
    \end{verbatim}
Recursive Type example:
    \begin{verbatim}
      data Tree a = Node a Tree Tree | Leaf a
    \end{verbatim}

\subsection{Typeclasses}
Paremetric polymorphism is done through typeclasses. Typeclasses define
implmentation of a function over members of the typeclass
\bigskip

Example functor typeclass with fmap
\begin{verbatim}
    class  Functor f  where
        fmap :: (a -> b) -> f a -> f b
\end{verbatim}

Example functor instance for a \verb|MyList| type
\begin{verbatim}
    instance Functor MyList where
        fmap f (Cons n rest) = Cons (f n) (fmap f rest)
        fmap f None = None
    \end{verbatim}
\FloatBarrier

\subsection{Applicatives}


\appendix
\end{document}
